{"ast":null,"code":"\"use strict\";\n\nlet acyclic = require(\"./acyclic\");\nlet normalize = require(\"./normalize\");\nlet rank = require(\"./rank\");\nlet normalizeRanks = require(\"./util\").normalizeRanks;\nlet parentDummyChains = require(\"./parent-dummy-chains\");\nlet removeEmptyRanks = require(\"./util\").removeEmptyRanks;\nlet nestingGraph = require(\"./nesting-graph\");\nlet addBorderSegments = require(\"./add-border-segments\");\nlet coordinateSystem = require(\"./coordinate-system\");\nlet order = require(\"./order\");\nlet position = require(\"./position\");\nlet util = require(\"./util\");\nlet Graph = require(\"@dagrejs/graphlib\").Graph;\nmodule.exports = layout;\nfunction layout(g, opts) {\n  let time = opts && opts.debugTiming ? util.time : util.notime;\n  time(\"layout\", () => {\n    let layoutGraph = time(\"  buildLayoutGraph\", () => buildLayoutGraph(g));\n    time(\"  runLayout\", () => runLayout(layoutGraph, time));\n    time(\"  updateInputGraph\", () => updateInputGraph(g, layoutGraph));\n  });\n}\nfunction runLayout(g, time) {\n  time(\"    makeSpaceForEdgeLabels\", () => makeSpaceForEdgeLabels(g));\n  time(\"    removeSelfEdges\", () => removeSelfEdges(g));\n  time(\"    acyclic\", () => acyclic.run(g));\n  time(\"    nestingGraph.run\", () => nestingGraph.run(g));\n  time(\"    rank\", () => rank(util.asNonCompoundGraph(g)));\n  time(\"    injectEdgeLabelProxies\", () => injectEdgeLabelProxies(g));\n  time(\"    removeEmptyRanks\", () => removeEmptyRanks(g));\n  time(\"    nestingGraph.cleanup\", () => nestingGraph.cleanup(g));\n  time(\"    normalizeRanks\", () => normalizeRanks(g));\n  time(\"    assignRankMinMax\", () => assignRankMinMax(g));\n  time(\"    removeEdgeLabelProxies\", () => removeEdgeLabelProxies(g));\n  time(\"    normalize.run\", () => normalize.run(g));\n  time(\"    parentDummyChains\", () => parentDummyChains(g));\n  time(\"    addBorderSegments\", () => addBorderSegments(g));\n  time(\"    order\", () => order(g));\n  time(\"    insertSelfEdges\", () => insertSelfEdges(g));\n  time(\"    adjustCoordinateSystem\", () => coordinateSystem.adjust(g));\n  time(\"    position\", () => position(g));\n  time(\"    positionSelfEdges\", () => positionSelfEdges(g));\n  time(\"    removeBorderNodes\", () => removeBorderNodes(g));\n  time(\"    normalize.undo\", () => normalize.undo(g));\n  time(\"    fixupEdgeLabelCoords\", () => fixupEdgeLabelCoords(g));\n  time(\"    undoCoordinateSystem\", () => coordinateSystem.undo(g));\n  time(\"    translateGraph\", () => translateGraph(g));\n  time(\"    assignNodeIntersects\", () => assignNodeIntersects(g));\n  time(\"    reversePoints\", () => reversePointsForReversedEdges(g));\n  time(\"    acyclic.undo\", () => acyclic.undo(g));\n}\n\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction updateInputGraph(inputGraph, layoutGraph) {\n  inputGraph.nodes().forEach(v => {\n    let inputLabel = inputGraph.node(v);\n    let layoutLabel = layoutGraph.node(v);\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n      inputLabel.rank = layoutLabel.rank;\n      if (layoutGraph.children(v).length) {\n        inputLabel.width = layoutLabel.width;\n        inputLabel.height = layoutLabel.height;\n      }\n    }\n  });\n  inputGraph.edges().forEach(e => {\n    let inputLabel = inputGraph.edge(e);\n    let layoutLabel = layoutGraph.edge(e);\n    inputLabel.points = layoutLabel.points;\n    if (layoutLabel.hasOwnProperty(\"x\")) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n    }\n  });\n  inputGraph.graph().width = layoutGraph.graph().width;\n  inputGraph.graph().height = layoutGraph.graph().height;\n}\nlet graphNumAttrs = [\"nodesep\", \"edgesep\", \"ranksep\", \"marginx\", \"marginy\"];\nlet graphDefaults = {\n  ranksep: 50,\n  edgesep: 20,\n  nodesep: 50,\n  rankdir: \"tb\"\n};\nlet graphAttrs = [\"acyclicer\", \"ranker\", \"rankdir\", \"align\"];\nlet nodeNumAttrs = [\"width\", \"height\"];\nlet nodeDefaults = {\n  width: 0,\n  height: 0\n};\nlet edgeNumAttrs = [\"minlen\", \"weight\", \"width\", \"height\", \"labeloffset\"];\nlet edgeDefaults = {\n  minlen: 1,\n  weight: 1,\n  width: 0,\n  height: 0,\n  labeloffset: 10,\n  labelpos: \"r\"\n};\nlet edgeAttrs = [\"labelpos\"];\n\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction buildLayoutGraph(inputGraph) {\n  let g = new Graph({\n    multigraph: true,\n    compound: true\n  });\n  let graph = canonicalize(inputGraph.graph());\n  g.setGraph(Object.assign({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), util.pick(graph, graphAttrs)));\n  inputGraph.nodes().forEach(v => {\n    let node = canonicalize(inputGraph.node(v));\n    const newNode = selectNumberAttrs(node, nodeNumAttrs);\n    Object.keys(nodeDefaults).forEach(k => {\n      if (newNode[k] === undefined) {\n        newNode[k] = nodeDefaults[k];\n      }\n    });\n    g.setNode(v, newNode);\n    g.setParent(v, inputGraph.parent(v));\n  });\n  inputGraph.edges().forEach(e => {\n    let edge = canonicalize(inputGraph.edge(e));\n    g.setEdge(e, Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), util.pick(edge, edgeAttrs)));\n  });\n  return g;\n}\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nfunction makeSpaceForEdgeLabels(g) {\n  let graph = g.graph();\n  graph.ranksep /= 2;\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    edge.minlen *= 2;\n    if (edge.labelpos.toLowerCase() !== \"c\") {\n      if (graph.rankdir === \"TB\" || graph.rankdir === \"BT\") {\n        edge.width += edge.labeloffset;\n      } else {\n        edge.height += edge.labeloffset;\n      }\n    }\n  });\n}\n\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nfunction injectEdgeLabelProxies(g) {\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    if (edge.width && edge.height) {\n      let v = g.node(e.v);\n      let w = g.node(e.w);\n      let label = {\n        rank: (w.rank - v.rank) / 2 + v.rank,\n        e: e\n      };\n      util.addDummyNode(g, \"edge-proxy\", label, \"_ep\");\n    }\n  });\n}\nfunction assignRankMinMax(g) {\n  let maxRank = 0;\n  g.nodes().forEach(v => {\n    let node = g.node(v);\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank;\n      node.maxRank = g.node(node.borderBottom).rank;\n      maxRank = Math.max(maxRank, node.maxRank);\n    }\n  });\n  g.graph().maxRank = maxRank;\n}\nfunction removeEdgeLabelProxies(g) {\n  g.nodes().forEach(v => {\n    let node = g.node(v);\n    if (node.dummy === \"edge-proxy\") {\n      g.edge(node.e).labelRank = node.rank;\n      g.removeNode(v);\n    }\n  });\n}\nfunction translateGraph(g) {\n  let minX = Number.POSITIVE_INFINITY;\n  let maxX = 0;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxY = 0;\n  let graphLabel = g.graph();\n  let marginX = graphLabel.marginx || 0;\n  let marginY = graphLabel.marginy || 0;\n  function getExtremes(attrs) {\n    let x = attrs.x;\n    let y = attrs.y;\n    let w = attrs.width;\n    let h = attrs.height;\n    minX = Math.min(minX, x - w / 2);\n    maxX = Math.max(maxX, x + w / 2);\n    minY = Math.min(minY, y - h / 2);\n    maxY = Math.max(maxY, y + h / 2);\n  }\n  g.nodes().forEach(v => getExtremes(g.node(v)));\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    if (edge.hasOwnProperty(\"x\")) {\n      getExtremes(edge);\n    }\n  });\n  minX -= marginX;\n  minY -= marginY;\n  g.nodes().forEach(v => {\n    let node = g.node(v);\n    node.x -= minX;\n    node.y -= minY;\n  });\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    edge.points.forEach(p => {\n      p.x -= minX;\n      p.y -= minY;\n    });\n    if (edge.hasOwnProperty(\"x\")) {\n      edge.x -= minX;\n    }\n    if (edge.hasOwnProperty(\"y\")) {\n      edge.y -= minY;\n    }\n  });\n  graphLabel.width = maxX - minX + marginX;\n  graphLabel.height = maxY - minY + marginY;\n}\nfunction assignNodeIntersects(g) {\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    let nodeV = g.node(e.v);\n    let nodeW = g.node(e.w);\n    let p1, p2;\n    if (!edge.points) {\n      edge.points = [];\n      p1 = nodeW;\n      p2 = nodeV;\n    } else {\n      p1 = edge.points[0];\n      p2 = edge.points[edge.points.length - 1];\n    }\n    edge.points.unshift(util.intersectRect(nodeV, p1));\n    edge.points.push(util.intersectRect(nodeW, p2));\n  });\n}\nfunction fixupEdgeLabelCoords(g) {\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    if (edge.hasOwnProperty(\"x\")) {\n      if (edge.labelpos === \"l\" || edge.labelpos === \"r\") {\n        edge.width -= edge.labeloffset;\n      }\n      switch (edge.labelpos) {\n        case \"l\":\n          edge.x -= edge.width / 2 + edge.labeloffset;\n          break;\n        case \"r\":\n          edge.x += edge.width / 2 + edge.labeloffset;\n          break;\n      }\n    }\n  });\n}\nfunction reversePointsForReversedEdges(g) {\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    if (edge.reversed) {\n      edge.points.reverse();\n    }\n  });\n}\nfunction removeBorderNodes(g) {\n  g.nodes().forEach(v => {\n    if (g.children(v).length) {\n      let node = g.node(v);\n      let t = g.node(node.borderTop);\n      let b = g.node(node.borderBottom);\n      let l = g.node(node.borderLeft[node.borderLeft.length - 1]);\n      let r = g.node(node.borderRight[node.borderRight.length - 1]);\n      node.width = Math.abs(r.x - l.x);\n      node.height = Math.abs(b.y - t.y);\n      node.x = l.x + node.width / 2;\n      node.y = t.y + node.height / 2;\n    }\n  });\n  g.nodes().forEach(v => {\n    if (g.node(v).dummy === \"border\") {\n      g.removeNode(v);\n    }\n  });\n}\nfunction removeSelfEdges(g) {\n  g.edges().forEach(e => {\n    if (e.v === e.w) {\n      var node = g.node(e.v);\n      if (!node.selfEdges) {\n        node.selfEdges = [];\n      }\n      node.selfEdges.push({\n        e: e,\n        label: g.edge(e)\n      });\n      g.removeEdge(e);\n    }\n  });\n}\nfunction insertSelfEdges(g) {\n  var layers = util.buildLayerMatrix(g);\n  layers.forEach(layer => {\n    var orderShift = 0;\n    layer.forEach((v, i) => {\n      var node = g.node(v);\n      node.order = i + orderShift;\n      (node.selfEdges || []).forEach(selfEdge => {\n        util.addDummyNode(g, \"selfedge\", {\n          width: selfEdge.label.width,\n          height: selfEdge.label.height,\n          rank: node.rank,\n          order: i + ++orderShift,\n          e: selfEdge.e,\n          label: selfEdge.label\n        }, \"_se\");\n      });\n      delete node.selfEdges;\n    });\n  });\n}\nfunction positionSelfEdges(g) {\n  g.nodes().forEach(v => {\n    var node = g.node(v);\n    if (node.dummy === \"selfedge\") {\n      var selfNode = g.node(node.e.v);\n      var x = selfNode.x + selfNode.width / 2;\n      var y = selfNode.y;\n      var dx = node.x - x;\n      var dy = selfNode.height / 2;\n      g.setEdge(node.e, node.label);\n      g.removeNode(v);\n      node.label.points = [{\n        x: x + 2 * dx / 3,\n        y: y - dy\n      }, {\n        x: x + 5 * dx / 6,\n        y: y - dy\n      }, {\n        x: x + dx,\n        y: y\n      }, {\n        x: x + 5 * dx / 6,\n        y: y + dy\n      }, {\n        x: x + 2 * dx / 3,\n        y: y + dy\n      }];\n      node.label.x = node.x;\n      node.label.y = node.y;\n    }\n  });\n}\nfunction selectNumberAttrs(obj, attrs) {\n  return util.mapValues(util.pick(obj, attrs), Number);\n}\nfunction canonicalize(attrs) {\n  var newAttrs = {};\n  if (attrs) {\n    Object.entries(attrs).forEach(([k, v]) => {\n      if (typeof k === \"string\") {\n        k = k.toLowerCase();\n      }\n      newAttrs[k] = v;\n    });\n  }\n  return newAttrs;\n}","map":{"version":3,"names":["acyclic","require","normalize","rank","normalizeRanks","parentDummyChains","removeEmptyRanks","nestingGraph","addBorderSegments","coordinateSystem","order","position","util","Graph","module","exports","layout","g","opts","time","debugTiming","notime","layoutGraph","buildLayoutGraph","runLayout","updateInputGraph","makeSpaceForEdgeLabels","removeSelfEdges","run","asNonCompoundGraph","injectEdgeLabelProxies","cleanup","assignRankMinMax","removeEdgeLabelProxies","insertSelfEdges","adjust","positionSelfEdges","removeBorderNodes","undo","fixupEdgeLabelCoords","translateGraph","assignNodeIntersects","reversePointsForReversedEdges","inputGraph","nodes","forEach","v","inputLabel","node","layoutLabel","x","y","children","length","width","height","edges","e","edge","points","hasOwnProperty","graph","graphNumAttrs","graphDefaults","ranksep","edgesep","nodesep","rankdir","graphAttrs","nodeNumAttrs","nodeDefaults","edgeNumAttrs","edgeDefaults","minlen","weight","labeloffset","labelpos","edgeAttrs","multigraph","compound","canonicalize","setGraph","Object","assign","selectNumberAttrs","pick","newNode","keys","k","undefined","setNode","setParent","parent","setEdge","toLowerCase","w","label","addDummyNode","maxRank","borderTop","minRank","borderBottom","Math","max","dummy","labelRank","removeNode","minX","Number","POSITIVE_INFINITY","maxX","minY","maxY","graphLabel","marginX","marginx","marginY","marginy","getExtremes","attrs","h","min","p","nodeV","nodeW","p1","p2","unshift","intersectRect","push","reversed","reverse","t","b","l","borderLeft","r","borderRight","abs","selfEdges","removeEdge","layers","buildLayerMatrix","layer","orderShift","i","selfEdge","selfNode","dx","dy","obj","mapValues","newAttrs","entries"],"sources":["/Users/ron/Documents/developer/patriothack/node_modules/@dagrejs/dagre/lib/layout.js"],"sourcesContent":["\"use strict\";\n\nlet acyclic = require(\"./acyclic\");\nlet normalize = require(\"./normalize\");\nlet rank = require(\"./rank\");\nlet normalizeRanks = require(\"./util\").normalizeRanks;\nlet parentDummyChains = require(\"./parent-dummy-chains\");\nlet removeEmptyRanks = require(\"./util\").removeEmptyRanks;\nlet nestingGraph = require(\"./nesting-graph\");\nlet addBorderSegments = require(\"./add-border-segments\");\nlet coordinateSystem = require(\"./coordinate-system\");\nlet order = require(\"./order\");\nlet position = require(\"./position\");\nlet util = require(\"./util\");\nlet Graph = require(\"@dagrejs/graphlib\").Graph;\n\nmodule.exports = layout;\n\nfunction layout(g, opts) {\n  let time = opts && opts.debugTiming ? util.time : util.notime;\n  time(\"layout\", () => {\n    let layoutGraph =\n      time(\"  buildLayoutGraph\", () => buildLayoutGraph(g));\n    time(\"  runLayout\",        () => runLayout(layoutGraph, time));\n    time(\"  updateInputGraph\", () => updateInputGraph(g, layoutGraph));\n  });\n}\n\nfunction runLayout(g, time) {\n  time(\"    makeSpaceForEdgeLabels\", () => makeSpaceForEdgeLabels(g));\n  time(\"    removeSelfEdges\",        () => removeSelfEdges(g));\n  time(\"    acyclic\",                () => acyclic.run(g));\n  time(\"    nestingGraph.run\",       () => nestingGraph.run(g));\n  time(\"    rank\",                   () => rank(util.asNonCompoundGraph(g)));\n  time(\"    injectEdgeLabelProxies\", () => injectEdgeLabelProxies(g));\n  time(\"    removeEmptyRanks\",       () => removeEmptyRanks(g));\n  time(\"    nestingGraph.cleanup\",   () => nestingGraph.cleanup(g));\n  time(\"    normalizeRanks\",         () => normalizeRanks(g));\n  time(\"    assignRankMinMax\",       () => assignRankMinMax(g));\n  time(\"    removeEdgeLabelProxies\", () => removeEdgeLabelProxies(g));\n  time(\"    normalize.run\",          () => normalize.run(g));\n  time(\"    parentDummyChains\",      () => parentDummyChains(g));\n  time(\"    addBorderSegments\",      () => addBorderSegments(g));\n  time(\"    order\",                  () => order(g));\n  time(\"    insertSelfEdges\",        () => insertSelfEdges(g));\n  time(\"    adjustCoordinateSystem\", () => coordinateSystem.adjust(g));\n  time(\"    position\",               () => position(g));\n  time(\"    positionSelfEdges\",      () => positionSelfEdges(g));\n  time(\"    removeBorderNodes\",      () => removeBorderNodes(g));\n  time(\"    normalize.undo\",         () => normalize.undo(g));\n  time(\"    fixupEdgeLabelCoords\",   () => fixupEdgeLabelCoords(g));\n  time(\"    undoCoordinateSystem\",   () => coordinateSystem.undo(g));\n  time(\"    translateGraph\",         () => translateGraph(g));\n  time(\"    assignNodeIntersects\",   () => assignNodeIntersects(g));\n  time(\"    reversePoints\",          () => reversePointsForReversedEdges(g));\n  time(\"    acyclic.undo\",           () => acyclic.undo(g));\n}\n\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction updateInputGraph(inputGraph, layoutGraph) {\n  inputGraph.nodes().forEach(v => {\n    let inputLabel = inputGraph.node(v);\n    let layoutLabel = layoutGraph.node(v);\n\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n      inputLabel.rank = layoutLabel.rank;\n\n      if (layoutGraph.children(v).length) {\n        inputLabel.width = layoutLabel.width;\n        inputLabel.height = layoutLabel.height;\n      }\n    }\n  });\n\n  inputGraph.edges().forEach(e => {\n    let inputLabel = inputGraph.edge(e);\n    let layoutLabel = layoutGraph.edge(e);\n\n    inputLabel.points = layoutLabel.points;\n    if (layoutLabel.hasOwnProperty(\"x\")) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n    }\n  });\n\n  inputGraph.graph().width = layoutGraph.graph().width;\n  inputGraph.graph().height = layoutGraph.graph().height;\n}\n\nlet graphNumAttrs = [\"nodesep\", \"edgesep\", \"ranksep\", \"marginx\", \"marginy\"];\nlet graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: \"tb\" };\nlet graphAttrs = [\"acyclicer\", \"ranker\", \"rankdir\", \"align\"];\nlet nodeNumAttrs = [\"width\", \"height\"];\nlet nodeDefaults = { width: 0, height: 0 };\nlet edgeNumAttrs = [\"minlen\", \"weight\", \"width\", \"height\", \"labeloffset\"];\nlet edgeDefaults = {\n  minlen: 1, weight: 1, width: 0, height: 0,\n  labeloffset: 10, labelpos: \"r\"\n};\nlet edgeAttrs = [\"labelpos\"];\n\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction buildLayoutGraph(inputGraph) {\n  let g = new Graph({ multigraph: true, compound: true });\n  let graph = canonicalize(inputGraph.graph());\n\n  g.setGraph(Object.assign({},\n    graphDefaults,\n    selectNumberAttrs(graph, graphNumAttrs),\n    util.pick(graph, graphAttrs)));\n\n  inputGraph.nodes().forEach(v => {\n    let node = canonicalize(inputGraph.node(v));\n    const newNode = selectNumberAttrs(node, nodeNumAttrs);\n    Object.keys(nodeDefaults).forEach(k => {\n      if (newNode[k] === undefined) {\n        newNode[k] = nodeDefaults[k];\n      }\n    });\n\n    g.setNode(v, newNode);\n    g.setParent(v, inputGraph.parent(v));\n  });\n\n  inputGraph.edges().forEach(e => {\n    let edge = canonicalize(inputGraph.edge(e));\n    g.setEdge(e, Object.assign({},\n      edgeDefaults,\n      selectNumberAttrs(edge, edgeNumAttrs),\n      util.pick(edge, edgeAttrs)));\n  });\n\n  return g;\n}\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nfunction makeSpaceForEdgeLabels(g) {\n  let graph = g.graph();\n  graph.ranksep /= 2;\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    edge.minlen *= 2;\n    if (edge.labelpos.toLowerCase() !== \"c\") {\n      if (graph.rankdir === \"TB\" || graph.rankdir === \"BT\") {\n        edge.width += edge.labeloffset;\n      } else {\n        edge.height += edge.labeloffset;\n      }\n    }\n  });\n}\n\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nfunction injectEdgeLabelProxies(g) {\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    if (edge.width && edge.height) {\n      let v = g.node(e.v);\n      let w = g.node(e.w);\n      let label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };\n      util.addDummyNode(g, \"edge-proxy\", label, \"_ep\");\n    }\n  });\n}\n\nfunction assignRankMinMax(g) {\n  let maxRank = 0;\n  g.nodes().forEach(v => {\n    let node = g.node(v);\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank;\n      node.maxRank = g.node(node.borderBottom).rank;\n      maxRank = Math.max(maxRank, node.maxRank);\n    }\n  });\n  g.graph().maxRank = maxRank;\n}\n\nfunction removeEdgeLabelProxies(g) {\n  g.nodes().forEach(v => {\n    let node = g.node(v);\n    if (node.dummy === \"edge-proxy\") {\n      g.edge(node.e).labelRank = node.rank;\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction translateGraph(g) {\n  let minX = Number.POSITIVE_INFINITY;\n  let maxX = 0;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxY = 0;\n  let graphLabel = g.graph();\n  let marginX = graphLabel.marginx || 0;\n  let marginY = graphLabel.marginy || 0;\n\n  function getExtremes(attrs) {\n    let x = attrs.x;\n    let y = attrs.y;\n    let w = attrs.width;\n    let h = attrs.height;\n    minX = Math.min(minX, x - w / 2);\n    maxX = Math.max(maxX, x + w / 2);\n    minY = Math.min(minY, y - h / 2);\n    maxY = Math.max(maxY, y + h / 2);\n  }\n\n  g.nodes().forEach(v => getExtremes(g.node(v)));\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    if (edge.hasOwnProperty(\"x\")) {\n      getExtremes(edge);\n    }\n  });\n\n  minX -= marginX;\n  minY -= marginY;\n\n  g.nodes().forEach(v => {\n    let node = g.node(v);\n    node.x -= minX;\n    node.y -= minY;\n  });\n\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    edge.points.forEach(p => {\n      p.x -= minX;\n      p.y -= minY;\n    });\n    if (edge.hasOwnProperty(\"x\")) { edge.x -= minX; }\n    if (edge.hasOwnProperty(\"y\")) { edge.y -= minY; }\n  });\n\n  graphLabel.width = maxX - minX + marginX;\n  graphLabel.height = maxY - minY + marginY;\n}\n\nfunction assignNodeIntersects(g) {\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    let nodeV = g.node(e.v);\n    let nodeW = g.node(e.w);\n    let p1, p2;\n    if (!edge.points) {\n      edge.points = [];\n      p1 = nodeW;\n      p2 = nodeV;\n    } else {\n      p1 = edge.points[0];\n      p2 = edge.points[edge.points.length - 1];\n    }\n    edge.points.unshift(util.intersectRect(nodeV, p1));\n    edge.points.push(util.intersectRect(nodeW, p2));\n  });\n}\n\nfunction fixupEdgeLabelCoords(g) {\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    if (edge.hasOwnProperty(\"x\")) {\n      if (edge.labelpos === \"l\" || edge.labelpos === \"r\") {\n        edge.width -= edge.labeloffset;\n      }\n      switch (edge.labelpos) {\n      case \"l\": edge.x -= edge.width / 2 + edge.labeloffset; break;\n      case \"r\": edge.x += edge.width / 2 + edge.labeloffset; break;\n      }\n    }\n  });\n}\n\nfunction reversePointsForReversedEdges(g) {\n  g.edges().forEach(e => {\n    let edge = g.edge(e);\n    if (edge.reversed) {\n      edge.points.reverse();\n    }\n  });\n}\n\nfunction removeBorderNodes(g) {\n  g.nodes().forEach(v => {\n    if (g.children(v).length) {\n      let node = g.node(v);\n      let t = g.node(node.borderTop);\n      let b = g.node(node.borderBottom);\n      let l = g.node(node.borderLeft[node.borderLeft.length - 1]);\n      let r = g.node(node.borderRight[node.borderRight.length - 1]);\n\n      node.width = Math.abs(r.x - l.x);\n      node.height = Math.abs(b.y - t.y);\n      node.x = l.x + node.width / 2;\n      node.y = t.y + node.height / 2;\n    }\n  });\n\n  g.nodes().forEach(v => {\n    if (g.node(v).dummy === \"border\") {\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction removeSelfEdges(g) {\n  g.edges().forEach(e => {\n    if (e.v === e.w) {\n      var node = g.node(e.v);\n      if (!node.selfEdges) {\n        node.selfEdges = [];\n      }\n      node.selfEdges.push({ e: e, label: g.edge(e) });\n      g.removeEdge(e);\n    }\n  });\n}\n\nfunction insertSelfEdges(g) {\n  var layers = util.buildLayerMatrix(g);\n  layers.forEach(layer => {\n    var orderShift = 0;\n    layer.forEach((v, i) => {\n      var node = g.node(v);\n      node.order = i + orderShift;\n      (node.selfEdges || []).forEach(selfEdge => {\n        util.addDummyNode(g, \"selfedge\", {\n          width: selfEdge.label.width,\n          height: selfEdge.label.height,\n          rank: node.rank,\n          order: i + (++orderShift),\n          e: selfEdge.e,\n          label: selfEdge.label\n        }, \"_se\");\n      });\n      delete node.selfEdges;\n    });\n  });\n}\n\nfunction positionSelfEdges(g) {\n  g.nodes().forEach(v => {\n    var node = g.node(v);\n    if (node.dummy === \"selfedge\") {\n      var selfNode = g.node(node.e.v);\n      var x = selfNode.x + selfNode.width / 2;\n      var y = selfNode.y;\n      var dx = node.x - x;\n      var dy = selfNode.height / 2;\n      g.setEdge(node.e, node.label);\n      g.removeNode(v);\n      node.label.points = [\n        { x: x + 2 * dx / 3, y: y - dy },\n        { x: x + 5 * dx / 6, y: y - dy },\n        { x: x +     dx    , y: y },\n        { x: x + 5 * dx / 6, y: y + dy },\n        { x: x + 2 * dx / 3, y: y + dy }\n      ];\n      node.label.x = node.x;\n      node.label.y = node.y;\n    }\n  });\n}\n\nfunction selectNumberAttrs(obj, attrs) {\n  return util.mapValues(util.pick(obj, attrs), Number);\n}\n\nfunction canonicalize(attrs) {\n  var newAttrs = {};\n  if (attrs) {\n    Object.entries(attrs).forEach(([k, v]) => {\n      if (typeof k === \"string\") {\n        k = k.toLowerCase();\n      }\n\n      newAttrs[k] = v;\n    });\n  }\n  return newAttrs;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}