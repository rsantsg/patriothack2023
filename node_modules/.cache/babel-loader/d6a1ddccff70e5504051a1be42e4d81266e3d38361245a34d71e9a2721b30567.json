{"ast":null,"code":"let util = require(\"./util\");\nmodule.exports = addBorderSegments;\nfunction addBorderSegments(g) {\n  function dfs(v) {\n    let children = g.children(v);\n    let node = g.node(v);\n    if (children.length) {\n      children.forEach(dfs);\n    }\n    if (node.hasOwnProperty(\"minRank\")) {\n      node.borderLeft = [];\n      node.borderRight = [];\n      for (let rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank) {\n        addBorderNode(g, \"borderLeft\", \"_bl\", v, node, rank);\n        addBorderNode(g, \"borderRight\", \"_br\", v, node, rank);\n      }\n    }\n  }\n  g.children().forEach(dfs);\n}\nfunction addBorderNode(g, prop, prefix, sg, sgNode, rank) {\n  let label = {\n    width: 0,\n    height: 0,\n    rank: rank,\n    borderType: prop\n  };\n  let prev = sgNode[prop][rank - 1];\n  let curr = util.addDummyNode(g, \"border\", label, prefix);\n  sgNode[prop][rank] = curr;\n  g.setParent(curr, sg);\n  if (prev) {\n    g.setEdge(prev, curr, {\n      weight: 1\n    });\n  }\n}","map":{"version":3,"names":["util","require","module","exports","addBorderSegments","g","dfs","v","children","node","length","forEach","hasOwnProperty","borderLeft","borderRight","rank","minRank","maxRank","addBorderNode","prop","prefix","sg","sgNode","label","width","height","borderType","prev","curr","addDummyNode","setParent","setEdge","weight"],"sources":["/Users/ron/Documents/developer/patriothack/node_modules/@dagrejs/dagre/lib/add-border-segments.js"],"sourcesContent":["let util = require(\"./util\");\n\nmodule.exports = addBorderSegments;\n\nfunction addBorderSegments(g) {\n  function dfs(v) {\n    let children = g.children(v);\n    let node = g.node(v);\n    if (children.length) {\n      children.forEach(dfs);\n    }\n\n    if (node.hasOwnProperty(\"minRank\")) {\n      node.borderLeft = [];\n      node.borderRight = [];\n      for (let rank = node.minRank, maxRank = node.maxRank + 1;\n        rank < maxRank;\n        ++rank) {\n        addBorderNode(g, \"borderLeft\", \"_bl\", v, node, rank);\n        addBorderNode(g, \"borderRight\", \"_br\", v, node, rank);\n      }\n    }\n  }\n\n  g.children().forEach(dfs);\n}\n\nfunction addBorderNode(g, prop, prefix, sg, sgNode, rank) {\n  let label = { width: 0, height: 0, rank: rank, borderType: prop };\n  let prev = sgNode[prop][rank - 1];\n  let curr = util.addDummyNode(g, \"border\", label, prefix);\n  sgNode[prop][rank] = curr;\n  g.setParent(curr, sg);\n  if (prev) {\n    g.setEdge(prev, curr, { weight: 1 });\n  }\n}\n"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAE5BC,MAAM,CAACC,OAAO,GAAGC,iBAAiB;AAElC,SAASA,iBAAiBA,CAACC,CAAC,EAAE;EAC5B,SAASC,GAAGA,CAACC,CAAC,EAAE;IACd,IAAIC,QAAQ,GAAGH,CAAC,CAACG,QAAQ,CAACD,CAAC,CAAC;IAC5B,IAAIE,IAAI,GAAGJ,CAAC,CAACI,IAAI,CAACF,CAAC,CAAC;IACpB,IAAIC,QAAQ,CAACE,MAAM,EAAE;MACnBF,QAAQ,CAACG,OAAO,CAACL,GAAG,CAAC;IACvB;IAEA,IAAIG,IAAI,CAACG,cAAc,CAAC,SAAS,CAAC,EAAE;MAClCH,IAAI,CAACI,UAAU,GAAG,EAAE;MACpBJ,IAAI,CAACK,WAAW,GAAG,EAAE;MACrB,KAAK,IAAIC,IAAI,GAAGN,IAAI,CAACO,OAAO,EAAEC,OAAO,GAAGR,IAAI,CAACQ,OAAO,GAAG,CAAC,EACtDF,IAAI,GAAGE,OAAO,EACd,EAAEF,IAAI,EAAE;QACRG,aAAa,CAACb,CAAC,EAAE,YAAY,EAAE,KAAK,EAAEE,CAAC,EAAEE,IAAI,EAAEM,IAAI,CAAC;QACpDG,aAAa,CAACb,CAAC,EAAE,aAAa,EAAE,KAAK,EAAEE,CAAC,EAAEE,IAAI,EAAEM,IAAI,CAAC;MACvD;IACF;EACF;EAEAV,CAAC,CAACG,QAAQ,CAAC,CAAC,CAACG,OAAO,CAACL,GAAG,CAAC;AAC3B;AAEA,SAASY,aAAaA,CAACb,CAAC,EAAEc,IAAI,EAAEC,MAAM,EAAEC,EAAE,EAAEC,MAAM,EAAEP,IAAI,EAAE;EACxD,IAAIQ,KAAK,GAAG;IAAEC,KAAK,EAAE,CAAC;IAAEC,MAAM,EAAE,CAAC;IAAEV,IAAI,EAAEA,IAAI;IAAEW,UAAU,EAAEP;EAAK,CAAC;EACjE,IAAIQ,IAAI,GAAGL,MAAM,CAACH,IAAI,CAAC,CAACJ,IAAI,GAAG,CAAC,CAAC;EACjC,IAAIa,IAAI,GAAG5B,IAAI,CAAC6B,YAAY,CAACxB,CAAC,EAAE,QAAQ,EAAEkB,KAAK,EAAEH,MAAM,CAAC;EACxDE,MAAM,CAACH,IAAI,CAAC,CAACJ,IAAI,CAAC,GAAGa,IAAI;EACzBvB,CAAC,CAACyB,SAAS,CAACF,IAAI,EAAEP,EAAE,CAAC;EACrB,IAAIM,IAAI,EAAE;IACRtB,CAAC,CAAC0B,OAAO,CAACJ,IAAI,EAAEC,IAAI,EAAE;MAAEI,MAAM,EAAE;IAAE,CAAC,CAAC;EACtC;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}