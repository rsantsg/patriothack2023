{"ast":null,"code":"/* eslint \"no-console\": off */\n\n\"use strict\";\n\nlet Graph = require(\"@dagrejs/graphlib\").Graph;\nmodule.exports = {\n  addBorderNode,\n  addDummyNode,\n  asNonCompoundGraph,\n  buildLayerMatrix,\n  intersectRect,\n  mapValues,\n  maxRank,\n  normalizeRanks,\n  notime,\n  partition,\n  pick,\n  predecessorWeights,\n  range,\n  removeEmptyRanks,\n  simplify,\n  successorWeights,\n  time,\n  uniqueId,\n  zipObject\n};\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nfunction addDummyNode(g, type, attrs, name) {\n  let v;\n  do {\n    v = uniqueId(name);\n  } while (g.hasNode(v));\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n}\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nfunction simplify(g) {\n  let simplified = new Graph().setGraph(g.graph());\n  g.nodes().forEach(v => simplified.setNode(v, g.node(v)));\n  g.edges().forEach(e => {\n    let simpleLabel = simplified.edge(e.v, e.w) || {\n      weight: 0,\n      minlen: 1\n    };\n    let label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    });\n  });\n  return simplified;\n}\nfunction asNonCompoundGraph(g) {\n  let simplified = new Graph({\n    multigraph: g.isMultigraph()\n  }).setGraph(g.graph());\n  g.nodes().forEach(v => {\n    if (!g.children(v).length) {\n      simplified.setNode(v, g.node(v));\n    }\n  });\n  g.edges().forEach(e => {\n    simplified.setEdge(e, g.edge(e));\n  });\n  return simplified;\n}\nfunction successorWeights(g) {\n  let weightMap = g.nodes().map(v => {\n    let sucs = {};\n    g.outEdges(v).forEach(e => {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n    });\n    return sucs;\n  });\n  return zipObject(g.nodes(), weightMap);\n}\nfunction predecessorWeights(g) {\n  let weightMap = g.nodes().map(v => {\n    let preds = {};\n    g.inEdges(v).forEach(e => {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return zipObject(g.nodes(), weightMap);\n}\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nfunction intersectRect(rect, point) {\n  let x = rect.x;\n  let y = rect.y;\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  let dx = point.x - x;\n  let dy = point.y - y;\n  let w = rect.width / 2;\n  let h = rect.height / 2;\n  if (!dx && !dy) {\n    throw new Error(\"Not possible to find intersection inside of the rectangle\");\n  }\n  let sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = w * dy / dx;\n  }\n  return {\n    x: x + sx,\n    y: y + sy\n  };\n}\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * function will produce a matrix with the ids of each node.\n */\nfunction buildLayerMatrix(g) {\n  let layering = range(maxRank(g) + 1).map(() => []);\n  g.nodes().forEach(v => {\n    let node = g.node(v);\n    let rank = node.rank;\n    if (rank !== undefined) {\n      layering[rank][node.order] = v;\n    }\n  });\n  return layering;\n}\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nfunction normalizeRanks(g) {\n  let min = Math.min(...g.nodes().map(v => {\n    let rank = g.node(v).rank;\n    if (rank === undefined) {\n      return Number.MAX_VALUE;\n    }\n    return rank;\n  }));\n  g.nodes().forEach(v => {\n    let node = g.node(v);\n    if (node.hasOwnProperty(\"rank\")) {\n      node.rank -= min;\n    }\n  });\n}\nfunction removeEmptyRanks(g) {\n  // Ranks may not start at 0, so we need to offset them\n  let offset = Math.min(...g.nodes().map(v => g.node(v).rank));\n  let layers = [];\n  g.nodes().forEach(v => {\n    let rank = g.node(v).rank - offset;\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n    layers[rank].push(v);\n  });\n  let delta = 0;\n  let nodeRankFactor = g.graph().nodeRankFactor;\n  Array.from(layers).forEach((vs, i) => {\n    if (vs === undefined && i % nodeRankFactor !== 0) {\n      --delta;\n    } else if (vs !== undefined && delta) {\n      vs.forEach(v => g.node(v).rank += delta);\n    }\n  });\n}\nfunction addBorderNode(g, prefix, rank, order) {\n  let node = {\n    width: 0,\n    height: 0\n  };\n  if (arguments.length >= 4) {\n    node.rank = rank;\n    node.order = order;\n  }\n  return addDummyNode(g, \"border\", node, prefix);\n}\nfunction maxRank(g) {\n  return Math.max(...g.nodes().map(v => {\n    let rank = g.node(v).rank;\n    if (rank === undefined) {\n      return Number.MIN_VALUE;\n    }\n    return rank;\n  }));\n}\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * function returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nfunction partition(collection, fn) {\n  let result = {\n    lhs: [],\n    rhs: []\n  };\n  collection.forEach(value => {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n}\n\n/*\n * Returns a new function that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nfunction time(name, fn) {\n  let start = Date.now();\n  try {\n    return fn();\n  } finally {\n    console.log(name + \" time: \" + (Date.now() - start) + \"ms\");\n  }\n}\nfunction notime(name, fn) {\n  return fn();\n}\nlet idCounter = 0;\nfunction uniqueId(prefix) {\n  var id = ++idCounter;\n  return toString(prefix) + id;\n}\nfunction range(start, limit, step = 1) {\n  if (limit == null) {\n    limit = start;\n    start = 0;\n  }\n  let endCon = i => i < limit;\n  if (step < 0) {\n    endCon = i => limit < i;\n  }\n  const range = [];\n  for (let i = start; endCon(i); i += step) {\n    range.push(i);\n  }\n  return range;\n}\nfunction pick(source, keys) {\n  const dest = {};\n  for (const key of keys) {\n    if (source[key] !== undefined) {\n      dest[key] = source[key];\n    }\n  }\n  return dest;\n}\nfunction mapValues(obj, funcOrProp) {\n  let func = funcOrProp;\n  if (typeof funcOrProp === 'string') {\n    func = val => val[funcOrProp];\n  }\n  return Object.entries(obj).reduce((acc, [k, v]) => {\n    acc[k] = func(v, k);\n    return acc;\n  }, {});\n}\nfunction zipObject(props, values) {\n  return props.reduce((acc, key, i) => {\n    acc[key] = values[i];\n    return acc;\n  }, {});\n}","map":{"version":3,"names":["Graph","require","module","exports","addBorderNode","addDummyNode","asNonCompoundGraph","buildLayerMatrix","intersectRect","mapValues","maxRank","normalizeRanks","notime","partition","pick","predecessorWeights","range","removeEmptyRanks","simplify","successorWeights","time","uniqueId","zipObject","g","type","attrs","name","v","hasNode","dummy","setNode","simplified","setGraph","graph","nodes","forEach","node","edges","e","simpleLabel","edge","w","weight","minlen","label","setEdge","Math","max","multigraph","isMultigraph","children","length","weightMap","map","sucs","outEdges","preds","inEdges","rect","point","x","y","dx","dy","width","h","height","Error","sx","sy","abs","layering","rank","undefined","order","min","Number","MAX_VALUE","hasOwnProperty","offset","layers","push","delta","nodeRankFactor","Array","from","vs","i","prefix","arguments","MIN_VALUE","collection","fn","result","lhs","rhs","value","start","Date","now","console","log","idCounter","id","toString","limit","step","endCon","source","keys","dest","key","obj","funcOrProp","func","val","Object","entries","reduce","acc","k","props","values"],"sources":["/Users/ron/Documents/developer/patriothack/node_modules/@dagrejs/dagre/lib/util.js"],"sourcesContent":["/* eslint \"no-console\": off */\n\n\"use strict\";\n\nlet Graph = require(\"@dagrejs/graphlib\").Graph;\n\nmodule.exports = {\n  addBorderNode,\n  addDummyNode,\n  asNonCompoundGraph,\n  buildLayerMatrix,\n  intersectRect,\n  mapValues,\n  maxRank,\n  normalizeRanks,\n  notime,\n  partition,\n  pick,\n  predecessorWeights,\n  range,\n  removeEmptyRanks,\n  simplify,\n  successorWeights,\n  time,\n  uniqueId,\n  zipObject,\n};\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nfunction addDummyNode(g, type, attrs, name) {\n  let v;\n  do {\n    v = uniqueId(name);\n  } while (g.hasNode(v));\n\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n}\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nfunction simplify(g) {\n  let simplified = new Graph().setGraph(g.graph());\n  g.nodes().forEach(v => simplified.setNode(v, g.node(v)));\n  g.edges().forEach(e => {\n    let simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };\n    let label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    });\n  });\n  return simplified;\n}\n\nfunction asNonCompoundGraph(g) {\n  let simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());\n  g.nodes().forEach(v => {\n    if (!g.children(v).length) {\n      simplified.setNode(v, g.node(v));\n    }\n  });\n  g.edges().forEach(e => {\n    simplified.setEdge(e, g.edge(e));\n  });\n  return simplified;\n}\n\nfunction successorWeights(g) {\n  let weightMap = g.nodes().map(v => {\n    let sucs = {};\n    g.outEdges(v).forEach(e => {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n    });\n    return sucs;\n  });\n  return zipObject(g.nodes(), weightMap);\n}\n\nfunction predecessorWeights(g) {\n  let weightMap = g.nodes().map(v => {\n    let preds = {};\n    g.inEdges(v).forEach(e => {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return zipObject(g.nodes(), weightMap);\n}\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nfunction intersectRect(rect, point) {\n  let x = rect.x;\n  let y = rect.y;\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  let dx = point.x - x;\n  let dy = point.y - y;\n  let w = rect.width / 2;\n  let h = rect.height / 2;\n\n  if (!dx && !dy) {\n    throw new Error(\"Not possible to find intersection inside of the rectangle\");\n  }\n\n  let sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = w * dy / dx;\n  }\n\n  return { x: x + sx, y: y + sy };\n}\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * function will produce a matrix with the ids of each node.\n */\nfunction buildLayerMatrix(g) {\n  let layering = range(maxRank(g) + 1).map(() => []);\n  g.nodes().forEach(v => {\n    let node = g.node(v);\n    let rank = node.rank;\n    if (rank !== undefined) {\n      layering[rank][node.order] = v;\n    }\n  });\n  return layering;\n}\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nfunction normalizeRanks(g) {\n  let min = Math.min(...g.nodes().map(v => {\n    let rank = g.node(v).rank;\n    if (rank === undefined) {\n      return Number.MAX_VALUE;\n    }\n\n    return rank;\n  }));\n  g.nodes().forEach(v => {\n    let node = g.node(v);\n    if (node.hasOwnProperty(\"rank\")) {\n      node.rank -= min;\n    }\n  });\n}\n\nfunction removeEmptyRanks(g) {\n  // Ranks may not start at 0, so we need to offset them\n  let offset = Math.min(...g.nodes().map(v => g.node(v).rank));\n\n  let layers = [];\n  g.nodes().forEach(v => {\n    let rank = g.node(v).rank - offset;\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n    layers[rank].push(v);\n  });\n\n  let delta = 0;\n  let nodeRankFactor = g.graph().nodeRankFactor;\n  Array.from(layers).forEach((vs, i) => {\n    if (vs === undefined && i % nodeRankFactor !== 0) {\n      --delta;\n    } else if (vs !== undefined && delta) {\n      vs.forEach(v => g.node(v).rank += delta);\n    }\n  });\n}\n\nfunction addBorderNode(g, prefix, rank, order) {\n  let node = {\n    width: 0,\n    height: 0\n  };\n  if (arguments.length >= 4) {\n    node.rank = rank;\n    node.order = order;\n  }\n  return addDummyNode(g, \"border\", node, prefix);\n}\n\nfunction maxRank(g) {\n  return Math.max(...g.nodes().map(v => {\n    let rank = g.node(v).rank;\n    if (rank === undefined) {\n      return Number.MIN_VALUE;\n    }\n\n    return rank;\n  }));\n}\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * function returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nfunction partition(collection, fn) {\n  let result = { lhs: [], rhs: [] };\n  collection.forEach(value => {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n}\n\n/*\n * Returns a new function that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nfunction time(name, fn) {\n  let start = Date.now();\n  try {\n    return fn();\n  } finally {\n    console.log(name + \" time: \" + (Date.now() - start) + \"ms\");\n  }\n}\n\nfunction notime(name, fn) {\n  return fn();\n}\n\nlet idCounter = 0;\nfunction uniqueId(prefix) {\n  var id = ++idCounter;\n  return toString(prefix) + id;\n}\n\nfunction range(start, limit, step = 1) {\n  if (limit == null) {\n    limit = start;\n    start = 0;\n  }\n\n  let endCon = (i) => i < limit;\n  if (step < 0) {\n    endCon = (i) => limit < i;\n  }\n\n  const range = [];\n  for (let i = start; endCon(i); i += step) {\n    range.push(i);\n  }\n\n  return range;\n}\n\nfunction pick(source, keys) {\n  const dest = {};\n  for (const key of keys) {\n    if (source[key] !== undefined) {\n      dest[key] = source[key];\n    }\n  }\n\n  return dest;\n}\n\nfunction mapValues(obj, funcOrProp) {\n  let func = funcOrProp;\n  if (typeof funcOrProp === 'string') {\n    func = (val) => val[funcOrProp];\n  }\n\n  return Object.entries(obj).reduce((acc, [k, v]) => {\n    acc[k] = func(v, k);\n    return acc;\n  }, {});\n}\n\nfunction zipObject(props, values) {\n  return props.reduce((acc, key, i) => {\n    acc[key] = values[i];\n    return acc;\n  }, {});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}