{"ast":null,"code":"\"use strict\";\n\nlet util = require(\"../util\");\nmodule.exports = initOrder;\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nfunction initOrder(g) {\n  let visited = {};\n  let simpleNodes = g.nodes().filter(v => !g.children(v).length);\n  let maxRank = Math.max(...simpleNodes.map(v => g.node(v).rank));\n  let layers = util.range(maxRank + 1).map(() => []);\n  function dfs(v) {\n    if (visited[v]) return;\n    visited[v] = true;\n    let node = g.node(v);\n    layers[node.rank].push(v);\n    g.successors(v).forEach(dfs);\n  }\n  let orderedVs = simpleNodes.sort((a, b) => g.node(a).rank - g.node(b).rank);\n  orderedVs.forEach(dfs);\n  return layers;\n}","map":{"version":3,"names":["util","require","module","exports","initOrder","g","visited","simpleNodes","nodes","filter","v","children","length","maxRank","Math","max","map","node","rank","layers","range","dfs","push","successors","forEach","orderedVs","sort","a","b"],"sources":["/Users/ron/Documents/developer/patriothack/node_modules/@dagrejs/dagre/lib/order/init-order.js"],"sourcesContent":["\"use strict\";\n\nlet util = require(\"../util\");\n\nmodule.exports = initOrder;\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nfunction initOrder(g) {\n  let visited = {};\n  let simpleNodes = g.nodes().filter(v => !g.children(v).length);\n  let maxRank = Math.max(...simpleNodes.map(v => g.node(v).rank));\n  let layers = util.range(maxRank + 1).map(() => []);\n\n  function dfs(v) {\n    if (visited[v]) return;\n    visited[v] = true;\n    let node = g.node(v);\n    layers[node.rank].push(v);\n    g.successors(v).forEach(dfs);\n  }\n\n  let orderedVs = simpleNodes.sort((a, b) => g.node(a).rank - g.node(b).rank);\n  orderedVs.forEach(dfs);\n\n  return layers;\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,IAAI,GAAGC,OAAO,CAAC,SAAS,CAAC;AAE7BC,MAAM,CAACC,OAAO,GAAGC,SAAS;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAASA,CAACC,CAAC,EAAE;EACpB,IAAIC,OAAO,GAAG,CAAC,CAAC;EAChB,IAAIC,WAAW,GAAGF,CAAC,CAACG,KAAK,CAAC,CAAC,CAACC,MAAM,CAACC,CAAC,IAAI,CAACL,CAAC,CAACM,QAAQ,CAACD,CAAC,CAAC,CAACE,MAAM,CAAC;EAC9D,IAAIC,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,GAAGR,WAAW,CAACS,GAAG,CAACN,CAAC,IAAIL,CAAC,CAACY,IAAI,CAACP,CAAC,CAAC,CAACQ,IAAI,CAAC,CAAC;EAC/D,IAAIC,MAAM,GAAGnB,IAAI,CAACoB,KAAK,CAACP,OAAO,GAAG,CAAC,CAAC,CAACG,GAAG,CAAC,MAAM,EAAE,CAAC;EAElD,SAASK,GAAGA,CAACX,CAAC,EAAE;IACd,IAAIJ,OAAO,CAACI,CAAC,CAAC,EAAE;IAChBJ,OAAO,CAACI,CAAC,CAAC,GAAG,IAAI;IACjB,IAAIO,IAAI,GAAGZ,CAAC,CAACY,IAAI,CAACP,CAAC,CAAC;IACpBS,MAAM,CAACF,IAAI,CAACC,IAAI,CAAC,CAACI,IAAI,CAACZ,CAAC,CAAC;IACzBL,CAAC,CAACkB,UAAU,CAACb,CAAC,CAAC,CAACc,OAAO,CAACH,GAAG,CAAC;EAC9B;EAEA,IAAII,SAAS,GAAGlB,WAAW,CAACmB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKvB,CAAC,CAACY,IAAI,CAACU,CAAC,CAAC,CAACT,IAAI,GAAGb,CAAC,CAACY,IAAI,CAACW,CAAC,CAAC,CAACV,IAAI,CAAC;EAC3EO,SAAS,CAACD,OAAO,CAACH,GAAG,CAAC;EAEtB,OAAOF,MAAM;AACf"},"metadata":{},"sourceType":"script","externalDependencies":[]}