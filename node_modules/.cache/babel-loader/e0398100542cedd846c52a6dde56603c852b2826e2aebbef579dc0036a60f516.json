{"ast":null,"code":"/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nclass PriorityQueue {\n  #arr = [];\n  #keyIndices = {};\n\n  /**\n   * Returns the number of elements in the queue. Takes `O(1)` time.\n   */\n  size() {\n    return this.#arr.length;\n  }\n\n  /**\n   * Returns the keys that are in the queue. Takes `O(n)` time.\n   */\n  keys() {\n    return this.#arr.map(function (x) {\n      return x.key;\n    });\n  }\n\n  /**\n   * Returns `true` if **key** is in the queue and `false` if not.\n   */\n  has(key) {\n    return this.#keyIndices.hasOwnProperty(key);\n  }\n\n  /**\n   * Returns the priority for **key**. If **key** is not present in the queue\n   * then this function returns `undefined`. Takes `O(1)` time.\n   *\n   * @param {Object} key\n   */\n  priority(key) {\n    var index = this.#keyIndices[key];\n    if (index !== undefined) {\n      return this.#arr[index].priority;\n    }\n  }\n\n  /**\n   * Returns the key for the minimum element in this queue. If the queue is\n   * empty this function throws an Error. Takes `O(1)` time.\n   */\n  min() {\n    if (this.size() === 0) {\n      throw new Error(\"Queue underflow\");\n    }\n    return this.#arr[0].key;\n  }\n\n  /**\n   * Inserts a new key into the priority queue. If the key already exists in\n   * the queue this function returns `false`; otherwise it will return `true`.\n   * Takes `O(n)` time.\n   *\n   * @param {Object} key the key to add\n   * @param {Number} priority the initial priority for the key\n   */\n  add(key, priority) {\n    var keyIndices = this.#keyIndices;\n    key = String(key);\n    if (!keyIndices.hasOwnProperty(key)) {\n      var arr = this.#arr;\n      var index = arr.length;\n      keyIndices[key] = index;\n      arr.push({\n        key: key,\n        priority: priority\n      });\n      this.#decrease(index);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n   */\n  removeMin() {\n    this.#swap(0, this.#arr.length - 1);\n    var min = this.#arr.pop();\n    delete this.#keyIndices[min.key];\n    this.#heapify(0);\n    return min.key;\n  }\n\n  /**\n   * Decreases the priority for **key** to **priority**. If the new priority is\n   * greater than the previous priority, this function will throw an Error.\n   *\n   * @param {Object} key the key for which to raise priority\n   * @param {Number} priority the new priority for the key\n   */\n  decrease(key, priority) {\n    var index = this.#keyIndices[key];\n    if (priority > this.#arr[index].priority) {\n      throw new Error(\"New priority is greater than current priority. \" + \"Key: \" + key + \" Old: \" + this.#arr[index].priority + \" New: \" + priority);\n    }\n    this.#arr[index].priority = priority;\n    this.#decrease(index);\n  }\n  #heapify(i) {\n    var arr = this.#arr;\n    var l = 2 * i;\n    var r = l + 1;\n    var largest = i;\n    if (l < arr.length) {\n      largest = arr[l].priority < arr[largest].priority ? l : largest;\n      if (r < arr.length) {\n        largest = arr[r].priority < arr[largest].priority ? r : largest;\n      }\n      if (largest !== i) {\n        this.#swap(i, largest);\n        this.#heapify(largest);\n      }\n    }\n  }\n  #decrease(index) {\n    var arr = this.#arr;\n    var priority = arr[index].priority;\n    var parent;\n    while (index !== 0) {\n      parent = index >> 1;\n      if (arr[parent].priority < priority) {\n        break;\n      }\n      this.#swap(index, parent);\n      index = parent;\n    }\n  }\n  #swap(i, j) {\n    var arr = this.#arr;\n    var keyIndices = this.#keyIndices;\n    var origArrI = arr[i];\n    var origArrJ = arr[j];\n    arr[i] = origArrJ;\n    arr[j] = origArrI;\n    keyIndices[origArrJ.key] = i;\n    keyIndices[origArrI.key] = j;\n  }\n}\nmodule.exports = PriorityQueue;","map":{"version":3,"names":["PriorityQueue","arr","keyIndices","size","length","keys","map","x","key","has","hasOwnProperty","priority","index","undefined","min","Error","add","String","push","decrease","removeMin","swap","pop","heapify","#heapify","i","l","r","largest","#decrease","parent","#swap","j","origArrI","origArrJ","module","exports"],"sources":["/Users/ron/Documents/developer/patriothack/node_modules/@dagrejs/graphlib/lib/data/priority-queue.js"],"sourcesContent":["/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nclass PriorityQueue {\n  #arr = [];\n  #keyIndices = {};\n\n  /**\n   * Returns the number of elements in the queue. Takes `O(1)` time.\n   */\n  size() {\n    return this.#arr.length;\n  }\n\n  /**\n   * Returns the keys that are in the queue. Takes `O(n)` time.\n   */\n  keys() {\n    return this.#arr.map(function(x) { return x.key; });\n  }\n\n  /**\n   * Returns `true` if **key** is in the queue and `false` if not.\n   */\n  has(key) {\n    return this.#keyIndices.hasOwnProperty(key);\n  }\n\n  /**\n   * Returns the priority for **key**. If **key** is not present in the queue\n   * then this function returns `undefined`. Takes `O(1)` time.\n   *\n   * @param {Object} key\n   */\n  priority(key) {\n    var index = this.#keyIndices[key];\n    if (index !== undefined) {\n      return this.#arr[index].priority;\n    }\n  }\n\n  /**\n   * Returns the key for the minimum element in this queue. If the queue is\n   * empty this function throws an Error. Takes `O(1)` time.\n   */\n  min() {\n    if (this.size() === 0) {\n      throw new Error(\"Queue underflow\");\n    }\n    return this.#arr[0].key;\n  }\n\n  /**\n   * Inserts a new key into the priority queue. If the key already exists in\n   * the queue this function returns `false`; otherwise it will return `true`.\n   * Takes `O(n)` time.\n   *\n   * @param {Object} key the key to add\n   * @param {Number} priority the initial priority for the key\n   */\n  add(key, priority) {\n    var keyIndices = this.#keyIndices;\n    key = String(key);\n    if (!keyIndices.hasOwnProperty(key)) {\n      var arr = this.#arr;\n      var index = arr.length;\n      keyIndices[key] = index;\n      arr.push({key: key, priority: priority});\n      this.#decrease(index);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n   */\n  removeMin() {\n    this.#swap(0, this.#arr.length - 1);\n    var min = this.#arr.pop();\n    delete this.#keyIndices[min.key];\n    this.#heapify(0);\n    return min.key;\n  }\n\n  /**\n   * Decreases the priority for **key** to **priority**. If the new priority is\n   * greater than the previous priority, this function will throw an Error.\n   *\n   * @param {Object} key the key for which to raise priority\n   * @param {Number} priority the new priority for the key\n   */\n  decrease(key, priority) {\n    var index = this.#keyIndices[key];\n    if (priority > this.#arr[index].priority) {\n      throw new Error(\"New priority is greater than current priority. \" +\n          \"Key: \" + key + \" Old: \" + this.#arr[index].priority + \" New: \" + priority);\n    }\n    this.#arr[index].priority = priority;\n    this.#decrease(index);\n  }\n\n  #heapify(i) {\n    var arr = this.#arr;\n    var l = 2 * i;\n    var r = l + 1;\n    var largest = i;\n    if (l < arr.length) {\n      largest = arr[l].priority < arr[largest].priority ? l : largest;\n      if (r < arr.length) {\n        largest = arr[r].priority < arr[largest].priority ? r : largest;\n      }\n      if (largest !== i) {\n        this.#swap(i, largest);\n        this.#heapify(largest);\n      }\n    }\n  }\n\n  #decrease(index) {\n    var arr = this.#arr;\n    var priority = arr[index].priority;\n    var parent;\n    while (index !== 0) {\n      parent = index >> 1;\n      if (arr[parent].priority < priority) {\n        break;\n      }\n      this.#swap(index, parent);\n      index = parent;\n    }\n  }\n\n  #swap(i, j) {\n    var arr = this.#arr;\n    var keyIndices = this.#keyIndices;\n    var origArrI = arr[i];\n    var origArrJ = arr[j];\n    arr[i] = origArrJ;\n    arr[j] = origArrI;\n    keyIndices[origArrJ.key] = i;\n    keyIndices[origArrI.key] = j;\n  }\n}\n\nmodule.exports = PriorityQueue;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}