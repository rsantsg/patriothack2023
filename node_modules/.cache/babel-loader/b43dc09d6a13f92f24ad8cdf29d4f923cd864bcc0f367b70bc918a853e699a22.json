{"ast":null,"code":"\"use strict\";\n\nlet util = require(\"../util\");\nmodule.exports = resolveConflicts;\n\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\nfunction resolveConflicts(entries, cg) {\n  let mappedEntries = {};\n  entries.forEach((entry, i) => {\n    let tmp = mappedEntries[entry.v] = {\n      indegree: 0,\n      \"in\": [],\n      out: [],\n      vs: [entry.v],\n      i: i\n    };\n    if (entry.barycenter !== undefined) {\n      tmp.barycenter = entry.barycenter;\n      tmp.weight = entry.weight;\n    }\n  });\n  cg.edges().forEach(e => {\n    let entryV = mappedEntries[e.v];\n    let entryW = mappedEntries[e.w];\n    if (entryV !== undefined && entryW !== undefined) {\n      entryW.indegree++;\n      entryV.out.push(mappedEntries[e.w]);\n    }\n  });\n  let sourceSet = Object.values(mappedEntries).filter(entry => !entry.indegree);\n  return doResolveConflicts(sourceSet);\n}\nfunction doResolveConflicts(sourceSet) {\n  let entries = [];\n  function handleIn(vEntry) {\n    return uEntry => {\n      if (uEntry.merged) {\n        return;\n      }\n      if (uEntry.barycenter === undefined || vEntry.barycenter === undefined || uEntry.barycenter >= vEntry.barycenter) {\n        mergeEntries(vEntry, uEntry);\n      }\n    };\n  }\n  function handleOut(vEntry) {\n    return wEntry => {\n      wEntry[\"in\"].push(vEntry);\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry);\n      }\n    };\n  }\n  while (sourceSet.length) {\n    let entry = sourceSet.pop();\n    entries.push(entry);\n    entry[\"in\"].reverse().forEach(handleIn(entry));\n    entry.out.forEach(handleOut(entry));\n  }\n  return entries.filter(entry => !entry.merged).map(entry => {\n    return util.pick(entry, [\"vs\", \"i\", \"barycenter\", \"weight\"]);\n  });\n}\nfunction mergeEntries(target, source) {\n  let sum = 0;\n  let weight = 0;\n  if (target.weight) {\n    sum += target.barycenter * target.weight;\n    weight += target.weight;\n  }\n  if (source.weight) {\n    sum += source.barycenter * source.weight;\n    weight += source.weight;\n  }\n  target.vs = source.vs.concat(target.vs);\n  target.barycenter = sum / weight;\n  target.weight = weight;\n  target.i = Math.min(source.i, target.i);\n  source.merged = true;\n}","map":{"version":3,"names":["util","require","module","exports","resolveConflicts","entries","cg","mappedEntries","forEach","entry","i","tmp","v","indegree","out","vs","barycenter","undefined","weight","edges","e","entryV","entryW","w","push","sourceSet","Object","values","filter","doResolveConflicts","handleIn","vEntry","uEntry","merged","mergeEntries","handleOut","wEntry","length","pop","reverse","map","pick","target","source","sum","concat","Math","min"],"sources":["/Users/ron/Documents/developer/patriothack/node_modules/@dagrejs/dagre/lib/order/resolve-conflicts.js"],"sourcesContent":["\"use strict\";\n\nlet util = require(\"../util\");\n\nmodule.exports = resolveConflicts;\n\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\nfunction resolveConflicts(entries, cg) {\n  let mappedEntries = {};\n  entries.forEach((entry, i) => {\n    let tmp = mappedEntries[entry.v] = {\n      indegree: 0,\n      \"in\": [],\n      out: [],\n      vs: [entry.v],\n      i: i\n    };\n    if (entry.barycenter !== undefined) {\n      tmp.barycenter = entry.barycenter;\n      tmp.weight = entry.weight;\n    }\n  });\n\n  cg.edges().forEach(e => {\n    let entryV = mappedEntries[e.v];\n    let entryW = mappedEntries[e.w];\n    if (entryV !== undefined && entryW !== undefined) {\n      entryW.indegree++;\n      entryV.out.push(mappedEntries[e.w]);\n    }\n  });\n\n  let sourceSet = Object.values(mappedEntries).filter(entry => !entry.indegree);\n\n  return doResolveConflicts(sourceSet);\n}\n\nfunction doResolveConflicts(sourceSet) {\n  let entries = [];\n\n  function handleIn(vEntry) {\n    return uEntry => {\n      if (uEntry.merged) {\n        return;\n      }\n      if (uEntry.barycenter === undefined ||\n          vEntry.barycenter === undefined ||\n          uEntry.barycenter >= vEntry.barycenter) {\n        mergeEntries(vEntry, uEntry);\n      }\n    };\n  }\n\n  function handleOut(vEntry) {\n    return wEntry => {\n      wEntry[\"in\"].push(vEntry);\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry);\n      }\n    };\n  }\n\n  while (sourceSet.length) {\n    let entry = sourceSet.pop();\n    entries.push(entry);\n    entry[\"in\"].reverse().forEach(handleIn(entry));\n    entry.out.forEach(handleOut(entry));\n  }\n\n  return entries.filter(entry => !entry.merged).map(entry => {\n    return util.pick(entry, [\"vs\", \"i\", \"barycenter\", \"weight\"]);\n  });\n}\n\nfunction mergeEntries(target, source) {\n  let sum = 0;\n  let weight = 0;\n\n  if (target.weight) {\n    sum += target.barycenter * target.weight;\n    weight += target.weight;\n  }\n\n  if (source.weight) {\n    sum += source.barycenter * source.weight;\n    weight += source.weight;\n  }\n\n  target.vs = source.vs.concat(target.vs);\n  target.barycenter = sum / weight;\n  target.weight = weight;\n  target.i = Math.min(source.i, target.i);\n  source.merged = true;\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,IAAI,GAAGC,OAAO,CAAC,SAAS,CAAC;AAE7BC,MAAM,CAACC,OAAO,GAAGC,gBAAgB;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,gBAAgBA,CAACC,OAAO,EAAEC,EAAE,EAAE;EACrC,IAAIC,aAAa,GAAG,CAAC,CAAC;EACtBF,OAAO,CAACG,OAAO,CAAC,CAACC,KAAK,EAAEC,CAAC,KAAK;IAC5B,IAAIC,GAAG,GAAGJ,aAAa,CAACE,KAAK,CAACG,CAAC,CAAC,GAAG;MACjCC,QAAQ,EAAE,CAAC;MACX,IAAI,EAAE,EAAE;MACRC,GAAG,EAAE,EAAE;MACPC,EAAE,EAAE,CAACN,KAAK,CAACG,CAAC,CAAC;MACbF,CAAC,EAAEA;IACL,CAAC;IACD,IAAID,KAAK,CAACO,UAAU,KAAKC,SAAS,EAAE;MAClCN,GAAG,CAACK,UAAU,GAAGP,KAAK,CAACO,UAAU;MACjCL,GAAG,CAACO,MAAM,GAAGT,KAAK,CAACS,MAAM;IAC3B;EACF,CAAC,CAAC;EAEFZ,EAAE,CAACa,KAAK,CAAC,CAAC,CAACX,OAAO,CAACY,CAAC,IAAI;IACtB,IAAIC,MAAM,GAAGd,aAAa,CAACa,CAAC,CAACR,CAAC,CAAC;IAC/B,IAAIU,MAAM,GAAGf,aAAa,CAACa,CAAC,CAACG,CAAC,CAAC;IAC/B,IAAIF,MAAM,KAAKJ,SAAS,IAAIK,MAAM,KAAKL,SAAS,EAAE;MAChDK,MAAM,CAACT,QAAQ,EAAE;MACjBQ,MAAM,CAACP,GAAG,CAACU,IAAI,CAACjB,aAAa,CAACa,CAAC,CAACG,CAAC,CAAC,CAAC;IACrC;EACF,CAAC,CAAC;EAEF,IAAIE,SAAS,GAAGC,MAAM,CAACC,MAAM,CAACpB,aAAa,CAAC,CAACqB,MAAM,CAACnB,KAAK,IAAI,CAACA,KAAK,CAACI,QAAQ,CAAC;EAE7E,OAAOgB,kBAAkB,CAACJ,SAAS,CAAC;AACtC;AAEA,SAASI,kBAAkBA,CAACJ,SAAS,EAAE;EACrC,IAAIpB,OAAO,GAAG,EAAE;EAEhB,SAASyB,QAAQA,CAACC,MAAM,EAAE;IACxB,OAAOC,MAAM,IAAI;MACf,IAAIA,MAAM,CAACC,MAAM,EAAE;QACjB;MACF;MACA,IAAID,MAAM,CAAChB,UAAU,KAAKC,SAAS,IAC/Bc,MAAM,CAACf,UAAU,KAAKC,SAAS,IAC/Be,MAAM,CAAChB,UAAU,IAAIe,MAAM,CAACf,UAAU,EAAE;QAC1CkB,YAAY,CAACH,MAAM,EAAEC,MAAM,CAAC;MAC9B;IACF,CAAC;EACH;EAEA,SAASG,SAASA,CAACJ,MAAM,EAAE;IACzB,OAAOK,MAAM,IAAI;MACfA,MAAM,CAAC,IAAI,CAAC,CAACZ,IAAI,CAACO,MAAM,CAAC;MACzB,IAAI,EAAEK,MAAM,CAACvB,QAAQ,KAAK,CAAC,EAAE;QAC3BY,SAAS,CAACD,IAAI,CAACY,MAAM,CAAC;MACxB;IACF,CAAC;EACH;EAEA,OAAOX,SAAS,CAACY,MAAM,EAAE;IACvB,IAAI5B,KAAK,GAAGgB,SAAS,CAACa,GAAG,CAAC,CAAC;IAC3BjC,OAAO,CAACmB,IAAI,CAACf,KAAK,CAAC;IACnBA,KAAK,CAAC,IAAI,CAAC,CAAC8B,OAAO,CAAC,CAAC,CAAC/B,OAAO,CAACsB,QAAQ,CAACrB,KAAK,CAAC,CAAC;IAC9CA,KAAK,CAACK,GAAG,CAACN,OAAO,CAAC2B,SAAS,CAAC1B,KAAK,CAAC,CAAC;EACrC;EAEA,OAAOJ,OAAO,CAACuB,MAAM,CAACnB,KAAK,IAAI,CAACA,KAAK,CAACwB,MAAM,CAAC,CAACO,GAAG,CAAC/B,KAAK,IAAI;IACzD,OAAOT,IAAI,CAACyC,IAAI,CAAChC,KAAK,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,YAAY,EAAE,QAAQ,CAAC,CAAC;EAC9D,CAAC,CAAC;AACJ;AAEA,SAASyB,YAAYA,CAACQ,MAAM,EAAEC,MAAM,EAAE;EACpC,IAAIC,GAAG,GAAG,CAAC;EACX,IAAI1B,MAAM,GAAG,CAAC;EAEd,IAAIwB,MAAM,CAACxB,MAAM,EAAE;IACjB0B,GAAG,IAAIF,MAAM,CAAC1B,UAAU,GAAG0B,MAAM,CAACxB,MAAM;IACxCA,MAAM,IAAIwB,MAAM,CAACxB,MAAM;EACzB;EAEA,IAAIyB,MAAM,CAACzB,MAAM,EAAE;IACjB0B,GAAG,IAAID,MAAM,CAAC3B,UAAU,GAAG2B,MAAM,CAACzB,MAAM;IACxCA,MAAM,IAAIyB,MAAM,CAACzB,MAAM;EACzB;EAEAwB,MAAM,CAAC3B,EAAE,GAAG4B,MAAM,CAAC5B,EAAE,CAAC8B,MAAM,CAACH,MAAM,CAAC3B,EAAE,CAAC;EACvC2B,MAAM,CAAC1B,UAAU,GAAG4B,GAAG,GAAG1B,MAAM;EAChCwB,MAAM,CAACxB,MAAM,GAAGA,MAAM;EACtBwB,MAAM,CAAChC,CAAC,GAAGoC,IAAI,CAACC,GAAG,CAACJ,MAAM,CAACjC,CAAC,EAAEgC,MAAM,CAAChC,CAAC,CAAC;EACvCiC,MAAM,CAACV,MAAM,GAAG,IAAI;AACtB"},"metadata":{},"sourceType":"script","externalDependencies":[]}