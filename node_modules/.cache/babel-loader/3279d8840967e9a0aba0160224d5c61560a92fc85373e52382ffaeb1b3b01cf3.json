{"ast":null,"code":"\"use strict\";\n\nlet zipObject = require(\"../util\").zipObject;\nmodule.exports = crossCount;\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount(g, layering) {\n  let cc = 0;\n  for (let i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n  return cc;\n}\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  let southPos = zipObject(southLayer, southLayer.map((v, i) => i));\n  let southEntries = northLayer.flatMap(v => {\n    return g.outEdges(v).map(e => {\n      return {\n        pos: southPos[e.w],\n        weight: g.edge(e).weight\n      };\n    }).sort((a, b) => a.pos - b.pos);\n  });\n\n  // Build the accumulator tree\n  let firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  let treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  let tree = new Array(treeSize).fill(0);\n\n  // Calculate the weighted crossings\n  let cc = 0;\n  southEntries.forEach(entry => {\n    let index = entry.pos + firstIndex;\n    tree[index] += entry.weight;\n    let weightSum = 0;\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1];\n      }\n      index = index - 1 >> 1;\n      tree[index] += entry.weight;\n    }\n    cc += entry.weight * weightSum;\n  });\n  return cc;\n}","map":{"version":3,"names":["zipObject","require","module","exports","crossCount","g","layering","cc","i","length","twoLayerCrossCount","northLayer","southLayer","southPos","map","v","southEntries","flatMap","outEdges","e","pos","w","weight","edge","sort","a","b","firstIndex","treeSize","tree","Array","fill","forEach","entry","index","weightSum"],"sources":["/Users/ron/Documents/developer/patriothack/node_modules/@dagrejs/dagre/lib/order/cross-count.js"],"sourcesContent":["\"use strict\";\n\nlet zipObject = require(\"../util\").zipObject;\n\nmodule.exports = crossCount;\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount(g, layering) {\n  let cc = 0;\n  for (let i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);\n  }\n  return cc;\n}\n\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  let southPos = zipObject(southLayer, southLayer.map((v, i) => i));\n  let southEntries = northLayer.flatMap(v => {\n    return g.outEdges(v).map(e => {\n      return { pos: southPos[e.w], weight: g.edge(e).weight };\n    }).sort((a, b) => a.pos - b.pos);\n  });\n\n  // Build the accumulator tree\n  let firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  let treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  let tree = new Array(treeSize).fill(0);\n\n  // Calculate the weighted crossings\n  let cc = 0;\n  southEntries.forEach(entry => {\n    let index = entry.pos + firstIndex;\n    tree[index] += entry.weight;\n    let weightSum = 0;\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1];\n      }\n      index = (index - 1) >> 1;\n      tree[index] += entry.weight;\n    }\n    cc += entry.weight * weightSum;\n  });\n\n  return cc;\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,SAAS,GAAGC,OAAO,CAAC,SAAS,CAAC,CAACD,SAAS;AAE5CE,MAAM,CAACC,OAAO,GAAGC,UAAU;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,UAAUA,CAACC,CAAC,EAAEC,QAAQ,EAAE;EAC/B,IAAIC,EAAE,GAAG,CAAC;EACV,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,CAACG,MAAM,EAAE,EAAED,CAAC,EAAE;IACxCD,EAAE,IAAIG,kBAAkB,CAACL,CAAC,EAAEC,QAAQ,CAACE,CAAC,GAAC,CAAC,CAAC,EAAEF,QAAQ,CAACE,CAAC,CAAC,CAAC;EACzD;EACA,OAAOD,EAAE;AACX;AAEA,SAASG,kBAAkBA,CAACL,CAAC,EAAEM,UAAU,EAAEC,UAAU,EAAE;EACrD;EACA;EACA;EACA,IAAIC,QAAQ,GAAGb,SAAS,CAACY,UAAU,EAAEA,UAAU,CAACE,GAAG,CAAC,CAACC,CAAC,EAAEP,CAAC,KAAKA,CAAC,CAAC,CAAC;EACjE,IAAIQ,YAAY,GAAGL,UAAU,CAACM,OAAO,CAACF,CAAC,IAAI;IACzC,OAAOV,CAAC,CAACa,QAAQ,CAACH,CAAC,CAAC,CAACD,GAAG,CAACK,CAAC,IAAI;MAC5B,OAAO;QAAEC,GAAG,EAAEP,QAAQ,CAACM,CAAC,CAACE,CAAC,CAAC;QAAEC,MAAM,EAAEjB,CAAC,CAACkB,IAAI,CAACJ,CAAC,CAAC,CAACG;MAAO,CAAC;IACzD,CAAC,CAAC,CAACE,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACL,GAAG,GAAGM,CAAC,CAACN,GAAG,CAAC;EAClC,CAAC,CAAC;;EAEF;EACA,IAAIO,UAAU,GAAG,CAAC;EAClB,OAAOA,UAAU,GAAGf,UAAU,CAACH,MAAM,EAAEkB,UAAU,KAAK,CAAC;EACvD,IAAIC,QAAQ,GAAG,CAAC,GAAGD,UAAU,GAAG,CAAC;EACjCA,UAAU,IAAI,CAAC;EACf,IAAIE,IAAI,GAAG,IAAIC,KAAK,CAACF,QAAQ,CAAC,CAACG,IAAI,CAAC,CAAC,CAAC;;EAEtC;EACA,IAAIxB,EAAE,GAAG,CAAC;EACVS,YAAY,CAACgB,OAAO,CAACC,KAAK,IAAI;IAC5B,IAAIC,KAAK,GAAGD,KAAK,CAACb,GAAG,GAAGO,UAAU;IAClCE,IAAI,CAACK,KAAK,CAAC,IAAID,KAAK,CAACX,MAAM;IAC3B,IAAIa,SAAS,GAAG,CAAC;IACjB,OAAOD,KAAK,GAAG,CAAC,EAAE;MAChB,IAAIA,KAAK,GAAG,CAAC,EAAE;QACbC,SAAS,IAAIN,IAAI,CAACK,KAAK,GAAG,CAAC,CAAC;MAC9B;MACAA,KAAK,GAAIA,KAAK,GAAG,CAAC,IAAK,CAAC;MACxBL,IAAI,CAACK,KAAK,CAAC,IAAID,KAAK,CAACX,MAAM;IAC7B;IACAf,EAAE,IAAI0B,KAAK,CAACX,MAAM,GAAGa,SAAS;EAChC,CAAC,CAAC;EAEF,OAAO5B,EAAE;AACX"},"metadata":{},"sourceType":"script","externalDependencies":[]}