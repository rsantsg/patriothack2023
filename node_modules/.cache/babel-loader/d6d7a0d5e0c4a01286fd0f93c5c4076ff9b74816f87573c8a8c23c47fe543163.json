{"ast":null,"code":"\"use strict\";\n\nlet initOrder = require(\"./init-order\");\nlet crossCount = require(\"./cross-count\");\nlet sortSubgraph = require(\"./sort-subgraph\");\nlet buildLayerGraph = require(\"./build-layer-graph\");\nlet addSubgraphConstraints = require(\"./add-subgraph-constraints\");\nlet Graph = require(\"@dagrejs/graphlib\").Graph;\nlet util = require(\"../util\");\nmodule.exports = order;\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  let maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, util.range(1, maxRank + 1), \"inEdges\"),\n    upLayerGraphs = buildLayerGraphs(g, util.range(maxRank - 1, -1, -1), \"outEdges\");\n  let layering = initOrder(g);\n  assignOrder(g, layering);\n  let bestCC = Number.POSITIVE_INFINITY,\n    best;\n  for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n    layering = util.buildLayerMatrix(g);\n    let cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = Object.assign({}, layering);\n      bestCC = cc;\n    }\n  }\n  assignOrder(g, best);\n}\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return ranks.map(function (rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  let cg = new Graph();\n  layerGraphs.forEach(function (lg) {\n    let root = lg.graph().root;\n    let sorted = sortSubgraph(lg, root, cg, biasRight);\n    sorted.vs.forEach((v, i) => lg.node(v).order = i);\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\nfunction assignOrder(g, layering) {\n  Object.values(layering).forEach(layer => layer.forEach((v, i) => g.node(v).order = i));\n}","map":{"version":3,"names":["initOrder","require","crossCount","sortSubgraph","buildLayerGraph","addSubgraphConstraints","Graph","util","module","exports","order","g","maxRank","downLayerGraphs","buildLayerGraphs","range","upLayerGraphs","layering","assignOrder","bestCC","Number","POSITIVE_INFINITY","best","i","lastBest","sweepLayerGraphs","buildLayerMatrix","cc","Object","assign","ranks","relationship","map","rank","layerGraphs","biasRight","cg","forEach","lg","root","graph","sorted","vs","v","node","values","layer"],"sources":["/Users/ron/Documents/developer/patriothack/node_modules/@dagrejs/dagre/lib/order/index.js"],"sourcesContent":["\"use strict\";\n\nlet initOrder = require(\"./init-order\");\nlet crossCount = require(\"./cross-count\");\nlet sortSubgraph = require(\"./sort-subgraph\");\nlet buildLayerGraph = require(\"./build-layer-graph\");\nlet addSubgraphConstraints = require(\"./add-subgraph-constraints\");\nlet Graph = require(\"@dagrejs/graphlib\").Graph;\nlet util = require(\"../util\");\n\nmodule.exports = order;\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  let maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, util.range(1, maxRank + 1), \"inEdges\"),\n    upLayerGraphs = buildLayerGraphs(g, util.range(maxRank - 1, -1, -1), \"outEdges\");\n\n  let layering = initOrder(g);\n  assignOrder(g, layering);\n\n  let bestCC = Number.POSITIVE_INFINITY,\n    best;\n\n  for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = util.buildLayerMatrix(g);\n    let cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = Object.assign({}, layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return ranks.map(function(rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  let cg = new Graph();\n  layerGraphs.forEach(function(lg) {\n    let root = lg.graph().root;\n    let sorted = sortSubgraph(lg, root, cg, biasRight);\n    sorted.vs.forEach((v, i) => lg.node(v).order = i);\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  Object.values(layering).forEach(layer => layer.forEach((v, i) => g.node(v).order = i));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}