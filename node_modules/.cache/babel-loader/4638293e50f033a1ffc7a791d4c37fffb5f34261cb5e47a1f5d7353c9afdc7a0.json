{"ast":null,"code":"module.exports = dfs;\n\n/*\n * A helper that preforms a pre- or post-order traversal on the input graph\n * and returns the nodes in the order they were visited. If the graph is\n * undirected then this algorithm will navigate using neighbors. If the graph\n * is directed then this algorithm will navigate using successors.\n *\n * If the order is not \"post\", it will be treated as \"pre\".\n */\nfunction dfs(g, vs, order) {\n  if (!Array.isArray(vs)) {\n    vs = [vs];\n  }\n  var navigation = g.isDirected() ? v => g.successors(v) : v => g.neighbors(v);\n  var orderFunc = order === \"post\" ? postOrderDfs : preOrderDfs;\n  var acc = [];\n  var visited = {};\n  vs.forEach(v => {\n    if (!g.hasNode(v)) {\n      throw new Error(\"Graph does not have node: \" + v);\n    }\n    orderFunc(v, navigation, visited, acc);\n  });\n  return acc;\n}\nfunction postOrderDfs(v, navigation, visited, acc) {\n  var stack = [[v, false]];\n  while (stack.length > 0) {\n    var curr = stack.pop();\n    if (curr[1]) {\n      acc.push(curr[0]);\n    } else {\n      if (!visited.hasOwnProperty(curr[0])) {\n        visited[curr[0]] = true;\n        stack.push([curr[0], true]);\n        forEachRight(navigation(curr[0]), w => stack.push([w, false]));\n      }\n    }\n  }\n}\nfunction preOrderDfs(v, navigation, visited, acc) {\n  var stack = [v];\n  while (stack.length > 0) {\n    var curr = stack.pop();\n    if (!visited.hasOwnProperty(curr)) {\n      visited[curr] = true;\n      acc.push(curr);\n      forEachRight(navigation(curr), w => stack.push(w));\n    }\n  }\n}\nfunction forEachRight(array, iteratee) {\n  var length = array.length;\n  while (length--) {\n    iteratee(array[length], length, array);\n  }\n  return array;\n}","map":{"version":3,"names":["module","exports","dfs","g","vs","order","Array","isArray","navigation","isDirected","v","successors","neighbors","orderFunc","postOrderDfs","preOrderDfs","acc","visited","forEach","hasNode","Error","stack","length","curr","pop","push","hasOwnProperty","forEachRight","w","array","iteratee"],"sources":["/Users/ron/Documents/developer/patriothack/node_modules/@dagrejs/graphlib/lib/alg/dfs.js"],"sourcesContent":["module.exports = dfs;\n\n/*\n * A helper that preforms a pre- or post-order traversal on the input graph\n * and returns the nodes in the order they were visited. If the graph is\n * undirected then this algorithm will navigate using neighbors. If the graph\n * is directed then this algorithm will navigate using successors.\n *\n * If the order is not \"post\", it will be treated as \"pre\".\n */\nfunction dfs(g, vs, order) {\n  if (!Array.isArray(vs)) {\n    vs = [vs];\n  }\n\n  var navigation = g.isDirected() ? v => g.successors(v) : v => g.neighbors(v);\n  var orderFunc = order === \"post\" ? postOrderDfs : preOrderDfs;\n\n  var acc = [];\n  var visited = {};\n  vs.forEach(v => {\n    if (!g.hasNode(v)) {\n      throw new Error(\"Graph does not have node: \" + v);\n    }\n\n    orderFunc(v, navigation, visited, acc);\n  });\n\n  return acc;\n}\n\nfunction postOrderDfs(v, navigation, visited, acc) {\n  var stack = [[v, false]];\n  while (stack.length > 0) {\n    var curr = stack.pop();\n    if (curr[1]) {\n      acc.push(curr[0]);\n    } else {\n      if (!visited.hasOwnProperty(curr[0])) {\n        visited[curr[0]] = true;\n        stack.push([curr[0], true]);\n        forEachRight(navigation(curr[0]), w => stack.push([w, false]));\n      }\n    }\n  }\n}\n\nfunction preOrderDfs(v, navigation, visited, acc) {\n  var stack = [v];\n  while (stack.length > 0) {\n    var curr = stack.pop();\n    if (!visited.hasOwnProperty(curr)) {\n      visited[curr] = true;\n      acc.push(curr);\n      forEachRight(navigation(curr), w => stack.push(w));\n    }\n  }\n}\n\nfunction forEachRight(array, iteratee) {\n  var length = array.length;\n  while (length--) {\n    iteratee(array[length], length, array);\n  }\n\n  return array;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}